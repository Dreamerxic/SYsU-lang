#!/bin/sh
# -*- python -*-
# This file is bilingual. The following shell code finds our preferred python.
# Following line is a shell no-op, and starts a multi-line Python comment.
# See https://stackoverflow.com/a/47886254
""":"
# prefer SYSU_PYTHON environment variable, python3, python
SYSU_PREFERRED_PYTHONS="python3 python"
for cmd in "${SYSU_PYTHON:-}" ${SYSU_PREFERRED_PYTHONS}; do
    if command -v "$cmd" >/dev/null; then
        export SYSU_PYTHON="$(command -v "$cmd")"
        exec "${SYSU_PYTHON}" "$0" "$@"
    fi
done
echo "==> Error: $0 could not find a python interpreter!" >&2
exit 1
":"""

import argparse
import glob
import gzip
import json
import logging
import os
import re
import statistics
import subprocess
import sys
import tempfile

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def unittest_parser(testcase, clang, preprocessor, parser, filenames, time_out):
    def check_ast(ast0, ast1, testcase, command0, command1):
        def wk_exit(n):
            logger.error("---")
            ast0.pop("inner")
            logger.error("current node: ")
            logger.error(ast0)
            logger.error("---")
            logger.error(command0)
            logger.error(command1)
            return n

        if type(ast0) != type(ast1):
            logger.error("\nfail: type err.")
            return wk_exit(-1)

        key_inner = ["inner"]

        if testcase in ["parser-0"]:
            key_kind = ["kind", "name", "value"]
        elif testcase in ["parser-1"]:
            key_kind = ["kind", "name", "value"]
        elif testcase in ["parser-2"]:
            key_kind = ["kind", "name", "value", "type", "valueCategory"]
        else:
            key_kind = []
        key_ignore = ["id", "range", "loc"]
        for key, value0 in ast0.items():
            if key in key_ignore:
                continue

            def get_value1():
                if key not in ast1:
                    logger.error("\nfail: key '"+key+"' not find")
                    return wk_exit(-1)
                return ast1.get(key)

            if key in key_inner:
                if ast0.get("kind") == "TranslationUnitDecl":
                    while len(value0[0].get("loc")) == 0:
                        value0.pop(0)
                value1 = get_value1()
                if len(value0) != len(value1):
                    logger.error("\nfail: inner not match")
                    return wk_exit(-1)
                for i in range(len(value0)):
                    check_ast(value0[i], value1[i],
                              testcase, command0, command1)
            elif len(key_kind) == 0 or key in key_kind:
                value1 = get_value1()
                if value0 != value1:
                    logger.error("\nfail: key not match")
                    logger.error(key)
                    return wk_exit(-1)
        return 0
    for ff in range(len(filenames)):
        filename = filenames[ff]
        logger.info("[{}/{}] {}".format(ff, len(filenames), filename))
        command = preprocessor + " " + filename
        src = subprocess.run(
            command, timeout=time_out, stdout=subprocess.PIPE, shell=True).stdout
        command0 = command+" | "+clang + " -cc1 -ast-dump=json"
        command1 = command+" | "+clang + " -cc1 -dump-tokens 2>&1 | "+parser
        ast0 = json.loads(subprocess.run(
            clang + " -cc1 -ast-dump=json",
            input=src, timeout=time_out,  stdout=subprocess.PIPE, shell=True).stdout)
        ast1 = json.loads(subprocess.run(
            clang + " -cc1 -dump-tokens 2>&1 |"+parser,
            input=src, timeout=time_out,  stdout=subprocess.PIPE, shell=True).stdout)

        r = check_ast(ast0, ast1, testcase, command0, command1)
        if r:
            return r


def unittest_lexer(testcase, clang, preprocessor, lexer, filenames, time_out):
    for ff in range(len(filenames)):
        filename = filenames[ff]
        logger.info("[{}/{}] {}".format(ff, len(filenames),
                                        filename))
        command = preprocessor + " " + filename
        src = subprocess.run(
            command, stdout=subprocess.PIPE, shell=True).stdout
        command0 = command+" | "+clang + " -cc1 -dump-tokens 2>&1 "
        command1 = command+" | "+lexer + " 2>&1 "
        tokens0 = subprocess.run(
            clang + " -cc1 -dump-tokens 2>&1 ",
            input=src, timeout=time_out,  stdout=subprocess.PIPE, shell=True).stdout.splitlines()
        tokens1 = subprocess.run(
            lexer + " 2>&1 ",
            input=src, timeout=time_out,  stdout=subprocess.PIPE, shell=True).stdout.splitlines()

        def wk_exit(n):
            logger.error("---")
            logger.error(command0)
            logger.error(command1)
            return n

        if len(tokens0) != len(tokens1):
            logger.error("\nfail: counts of tokens are different")
            return wk_exit(-1)
        for i in range(len(tokens0)):
            def split_tokens(t):
                tmp = str(t, encoding="utf8")
                k1 = tmp.find("'")
                k2 = tmp.rfind("'")
                k3 = tmp.rfind("Loc=<")
                if k1 == -1 or k2 == -1 or k3 == -1:
                    logger.error("\nfail: format error")
                    logger.error("---")
                    logger.error(t)
                    return wk_exit(-1)
                tok0 = tmp.split()[0].strip()
                str0 = tmp[k1+1:k2].strip()
                mid0 = str(tmp[k2+1:k3].strip().split())
                loc0 = tmp[k3:].strip()
                return [tok0, str0, mid0, loc0]
            tok0, str0, mid0, loc0 = split_tokens(tokens0[i])
            tok1, str1, mid1, loc1 = split_tokens(tokens1[i])

            if testcase in ["lexer-3"]:
                if mid0 != mid1:
                    logger.error("\nfail: mid " + str(i+1) + "c" + str(i+1))
                    logger.error("< " + mid0)
                    logger.error("---")
                    logger.error("> " + mid1)
                    return wk_exit(-1)
            if testcase in ["lexer-2", "lexer-3"]:
                if loc0 != loc1:
                    logger.error("\nfail: loc " + str(i+1) + "c" + str(i+1))
                    logger.error("< " + loc0)
                    logger.error("---")
                    logger.error("> " + loc1)
                    return wk_exit(-1)
            if testcase in ["lexer-0", "lexer-1", "lexer-2", "lexer-3"]:
                if tok0 != tok1:
                    logger.error("\nfail: tok " + str(i+1) + "c" + str(i+1))
                    logger.error("< " + tok0)
                    logger.error("---")
                    logger.error("> " + tok1)
                    return wk_exit(-1)
                if str0 != str1:
                    logger.error("\nfail: str " + str(i+1) + "c" + str(i+1))
                    logger.error("< " + str0)
                    logger.error("---")
                    logger.error("> " + str1)
                    return wk_exit(-1)


def convert_sysy(filenames):
    for ff in range(len(filenames)):
        filename = filenames[ff]
        logger.info("[{}/{}] {}".format(ff, len(filenames), filename))
        if filename.endswith(".sy"):
            file = open(filename, mode="r")
            src = file.read()
            file.close()
            patterns = ["getint", "getch", "getarray", "putint",
                        "putch", "putarray", "starttime", "stoptime"]
            for pattern in patterns:
                if src.find(pattern) != -1:
                    src = "#include <sysy/sylib.h>\n"+src
                    break
            file = open(filename+"su.c", mode="w")
            file.write(src)
            file.close()
    return 0


def benchmark_generator_and_optimizer(
        testcase,
        clang,
        generator,
        optimizer,
        filenames,
        time_out):
    results = {"tests": []}

    def wk_exit(n):
        print(json.dumps(results))
        return n

    for ff in range(len(filenames)):
        filename = filenames[ff]
        results["tests"].append({"name": filename, "score": 0, "max_score": 1})
    performance = []
    with tempfile.TemporaryDirectory() as tmpdirname:
        ir = os.path.join(tmpdirname, "a.ll")
        exe = os.path.join(tmpdirname, "a.out")
        for ff in range(len(filenames)):
            filename = filenames[ff]
            logger.info("[{}/{}] {}".format(ff, len(filenames),
                                            filename))

            def get_tm(sp):
                val = -1
                matchObj = re.findall(
                    b'TOTAL: (\\d*)H-(\\d*)M-(\\d*)S-(\\d*)us', sp.stderr)
                matchObj = matchObj[-1]
                val = int(matchObj[0])
                val = val * 60 + int(matchObj[1])
                val = val * 60 + int(matchObj[2])
                val = val * 1000000 + int(matchObj[3])
                return val

            sysu = [subprocess.run(
                    [clang, "-O3", "-S", "-emit-llvm", "-o-", filename],
                    timeout=time_out,
                    stdout=subprocess.PIPE)]
            test_clang = 0
            if test_clang:
                sysu.append(subprocess.run(
                    [clang, "-O0", "-S", "-emit-llvm", "-o-", filename],
                    timeout=time_out,
                    stdout=subprocess.PIPE))
            else:
                s = subprocess.run(
                    ["clang", "-E", "-O0", filename],
                    timeout=time_out,
                    stdout=subprocess.PIPE)
                s = subprocess.run(
                    [clang, "-cc1", "-O0", "-ast-dump=json"],
                    timeout=time_out,
                    input=s.stdout,
                    stdout=subprocess.PIPE)
                if s.returncode:
                    return wk_exit(s.returncode)
                for it in [generator, optimizer]:
                    s = subprocess.run(
                        [it], timeout=time_out, input=s.stdout, stdout=subprocess.PIPE)
                    if s.returncode:
                        return wk_exit(s.returncode)
                sysu.append(s)
            inputs = None
            if filename.endswith(".sysu.c"):
                gz = filename[0:filename.rfind(".sysu.c")]+".in.gz"
                if os.path.exists(gz):
                    with gzip.open(gz, "rb") as f:
                        inputs = f.read()
            res = []
            try:
                for it in sysu:
                    with open(ir, "wb") as f:
                        f.write(it.stdout)
                    r = subprocess.run(
                        [clang, "-O0", "-lsysy", "-o", exe, ir],
                        timeout=time_out).returncode
                    if r:
                        logger.error("ir error")
                        return wk_exit(r)
                    jt = subprocess.run(
                        [exe],
                        timeout=time_out,
                        input=inputs,
                        stderr=subprocess.PIPE,
                        stdout=subprocess.PIPE)
                    res.append(jt)
                    if len(res) == 1:
                        logger.info("[{}/{}] clang -O3: {}us, ret {}".format(
                            ff, len(filenames), get_tm(jt), jt.returncode))
                    else:
                        logger.info("[{}/{}] sysu-lang: {}us, ret {}".format(
                            ff, len(filenames), get_tm(jt), jt.returncode))
                        if res[0].returncode != jt.returncode or res[0].stdout != jt.stdout:
                            logger.error("fail: not equ")
                            return wk_exit(-1)
                        if get_tm(res[0]) > 0:
                            if get_tm(jt) <= 0:
                                logger.error("fail: no timer")
                                return wk_exit(-1)
                            performance.append(get_tm(res[0])/get_tm(jt))
                        results["tests"][ff]["score"] = 1
            except subprocess.TimeoutExpired:
                if len(res) != 1:
                    logger.error("fail: TimeoutExpired")
                    return wk_exit(-1)
                if get_tm(res[0]) > 0:
                    performance.append(get_tm(res[0])/(time_out * 1000000))
        if len(performance):
            results["leaderboard"] = [{
                "name": "performance",
                "order": 1,
                "is_desc": True,
                "value": statistics.geometric_mean(performance)}]
    return wk_exit(0)


def compile(
        preprocessor,
        lexer,
        parser,
        generator,
        optimizer,
        translator,
        linker,
        filenames):
    for filename in filenames:
        sysu = subprocess.run(
            [preprocessor, filename],
            stdout=subprocess.PIPE)
        if sysu.returncode:
            return sysu.returncode
        for it in [lexer, parser, generator, optimizer, translator]:
            sysu = subprocess.run(
                [it],
                stdout=subprocess.PIPE,
                input=sysu.stdout)
            if sysu.returncode:
                return sysu.returncode
        print(str(sysu.stdout, encoding="utf8"))

    return 0


def main(*argv):
    parser = argparse.ArgumentParser(prog=os.path.basename(argv[0]))
    specs = ["clang", "sysu-preprocessor", "sysu-lexer", "sysu-parser",
             "sysu-generator", "sysu-optimizer", "sysu-translator", "sysu-linker"]
    for spec in specs:
        parser.add_argument("--"+spec, help="Specify "+spec, default=spec)
    parser.add_argument("--unittest")
    parser.add_argument(
        "--unittest-timeout",
        help="unittest-timeout in seconds, '-1' for no skip (default 300)",
        type=int,  # 慎重测试！
        default=300)
    parser.add_argument(
        "--convert-sysy",
        help="Convert *.sy in [file ...]",
        action="store_true")
    parser.add_argument(
        "--skip-filesize",
        help="'-1' for no skip (default 32768)",
        type=int,  # 慎重测试！
        default=32768)
    parser.add_argument("file", default=["-"], nargs="*")
    args = parser.parse_args(argv[1:])
    filenames = []
    for f in args.file:
        tmp = glob.glob(f, recursive=True)
        for t in tmp:
            if args.skip_filesize >= 0:
                if os.path.getsize(t) >= args.skip_filesize:
                    continue
            if t not in filenames:
                filenames.append(t)
    if args.convert_sysy:
        return convert_sysy(filenames)
    if args.unittest:
        filenames.sort()
        time_out = None
        if args.unittest_timeout >= 0:
            time_out = args.unittest_timeout
        if "lexer" in args.unittest:
            return unittest_lexer(args.unittest, args.clang,
                                  args.sysu_preprocessor, args.sysu_lexer,
                                  filenames, time_out)
        if "parser" in args.unittest:
            return unittest_parser(args.unittest, args.clang,
                                   args.sysu_preprocessor, args.sysu_parser,
                                   filenames, time_out)
        if "benchmark_generator_and_optimizer" in args.unittest:
            return benchmark_generator_and_optimizer(
                args.unittest,
                args.clang,
                args.sysu_generator,
                args.sysu_optimizer,
                filenames,
                time_out)
    returncode = compile(args.sysu_preprocessor, args.sysu_lexer,
                         args.sysu_parser, args.sysu_generator,
                         args.sysu_optimizer, args.sysu_translator,
                         args.sysu_linker, filenames)
    return returncode


if __name__ == '__main__':
    exit(main(*sys.argv))
